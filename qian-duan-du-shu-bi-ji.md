### 关于Polyfill的注解

一个polyfill是指一种功能的模拟，这虚无缥缈功能在新版本的浏览器中已经完备定义并原生实现了。例如ECMA5为数组增加了forEavh的函数。该方法可以在ECMA3中模拟。以便 在老的版本浏览器中如同新版一样使用。

Object.freeze函数可以冻结一个对象，这里的功能点是可以放在现在的工程中去实用的，应用场景的话。自己的默认属性是不可以被修改的。

### 自动化

思考每项编程的点是否可以抽象成自动化，然后实现之，等累计多了之后就再抽象化，形成一个小的工具链。

* 静态分析可以自动发现错误
* 在部署之前有多种方式处理JS，比如文件的连接和压缩
* 通过自动化测试可以很容易地发现问题
* 很方便的自动部署到生产环境
* 可以轻松快速地重新执行常见任务。

* 每次修改后可能都需要在本地重新构建。

* 部署到生产的代码看起来并不像我们在开发环境编辑的代码。Bug挑食困难
* 技术水平偏低的开发人员全名用构建系统可能会遇到问题

### 文件和目录结构

* 一个文件只包含一个对象
* 保持第三方代码的独立
  * 使用CDN或者单独放到一个文件夹里
* 确定创建位置
* * 源码文件应该到哪单独的一个文件里例如常见的src，使用编译后的目录而非源码目录。不要把编译后的内容提交到源码工程里。因为编译后的内容都是成型的工件
* 保持测试代码的完整性

```
build/ 最终构建后的文件
src/  所有的源文件
test/  或者 tests/
docs/文档目录
```

![](/assets/csslint.png)

压缩：

运行时压缩：web服务器都支持运行时执行文件压缩。实际情况这些压缩一般仅仅适用于基本于文件的文件。像JS HTML CSS现代浏览器都支持http压缩并且都会发送一个http的头作业为请求的一部分。指明压缩类型。

Accept-encoding:gzip, defalate

当服务器接收到此请求头时，就知道浏览器支持通过gzip等压缩方式，当服务器响应时它会设置头信息

Content-Encoding:gzip

默认ngxinx 和apache都是支持gzip的但是不代理sre同学不把这些规则删除掉

文档化

所有工程师都喜欢写代码，不喜欢写文档，自动化文档的重要性

build system

基于对象的继承 Object.create

冻结对象 Object.frzzied





























